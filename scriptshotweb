#!/usr/bin/env python3
"""
ScriptShotWeb - Herramienta simplificada para capturas de pantalla web
Uso: scriptshotweb URL [-all] [--device DEVICE] [--wait-time SECONDS] [--smooth-scroll] [--super]

Ejemplos:
  scriptshotweb http://mariadelasmercedes.com/contacto -all
  scriptshotweb https://mecalito.com --device mobile-17
  scriptshotweb https://example.com --device tablet --wait-time 5 --smooth-scroll
  scriptshotweb https://site.com --super  # Modo completo optimizado
"""

import argparse
import sys
from pathlib import Path
from urllib.parse import urlparse
from datetime import datetime
import re
import time
# Importaciones de playwright y requests se har√°n m√°s tarde para permitir que --help funcione

def mostrar_ayuda_extendida():
    """Muestra informaci√≥n adicional sobre el uso del script"""
    ayuda = """
‚ïî‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïó
‚ïë                           SCRIPTSHOTWEB - GU√çA COMPLETA                      ‚ïë
‚ïö‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïù

üìñ DESCRIPCI√ìN:
   ScriptShotWeb es una herramienta profesional para realizar capturas de pantalla
   de sitios web en m√∫ltiples dispositivos, optimizada para sitios modernos con
   animaciones, efectos de scroll y contenido din√°mico.

üéØ CARACTER√çSTICAS PRINCIPALES:
   ‚Ä¢ Capturas en 4 tama√±os de dispositivo predefinidos
   ‚Ä¢ Soporte para animaciones y contenido que se carga con delay
   ‚Ä¢ Scroll suave para disparar animaciones basadas en scroll
   ‚Ä¢ Organizaci√≥n autom√°tica de archivos por cliente y dispositivo
   ‚Ä¢ Modo super para captura completa optimizada

üì± DISPOSITIVOS DISPONIBLES:
   mobile-se  ‚îÇ iPhone SE      ‚îÇ 375 √ó 667   ‚îÇ M√≥vil peque√±o
   mobile-17  ‚îÇ iPhone 17      ‚îÇ 393 √ó 852   ‚îÇ M√≥vil moderno  
   tablet     ‚îÇ iPad           ‚îÇ 768 √ó 1024  ‚îÇ Tablet est√°ndar
   desktop    ‚îÇ Desktop        ‚îÇ 1920 √ó 1080 ‚îÇ Escritorio HD

üöÄ MODOS DE USO:

   B√°sico (un dispositivo):
   $ scriptshotweb https://example.com --device desktop

   Completo (todos los dispositivos):  
   $ scriptshotweb https://example.com --all-devices

   Super optimizado (recomendado para sitios complejos):
   $ scriptshotweb https://example.com --super

‚öôÔ∏è  OPCIONES AVANZADAS:
   --wait-time SEGUNDOS    ‚îÇ Tiempo de espera para animaciones (default: 3s)
   --smooth-scroll         ‚îÇ Scroll suave antes de captura completa
   --cliente NOMBRE        ‚îÇ Nombre personalizado para organizar archivos
   --output-dir PATH       ‚îÇ Directorio personalizado de salida

üìÇ ESTRUCTURA DE ARCHIVOS:
   Las capturas se guardan por defecto en:
   ./capturas/ (carpeta en el proyecto)
   ‚îî‚îÄ‚îÄ [cliente]/
       ‚îú‚îÄ‚îÄ mobile-se/
       ‚îú‚îÄ‚îÄ mobile-17/ 
       ‚îú‚îÄ‚îÄ tablet/
       ‚îî‚îÄ‚îÄ desktop/
           ‚îú‚îÄ‚îÄ pagina-viewport-20241004_143025.png
           ‚îî‚îÄ‚îÄ pagina-completa-20241004_143025.png
   
   Usa --output-dir para guardar en otra ubicaci√≥n como:
   ~/Pictures/ScriptShotWeb o ~/Downloads/ScriptShotWeb

üí° CONSEJOS:
   ‚Ä¢ Usa --super para sitios con muchas animaciones
   ‚Ä¢ Usa --wait-time mayor para sitios lentos
   ‚Ä¢ El scroll suave es ideal para lazy loading y parallax
   ‚Ä¢ Las URLs deben incluir http:// o https://

"""
    print(ayuda)

# Configuraci√≥n de dispositivos/tama√±os
TAMA√ëOS = {
    "mobile-se": {"width": 375, "height": 667, "nombre": "iPhone SE"},
    "mobile-17": {"width": 393, "height": 852, "nombre": "iPhone 17"},
    "tablet": {"width": 768, "height": 1024, "nombre": "iPad"},
    "desktop": {"width": 1920, "height": 1080, "nombre": "Desktop"}
}

def validar_url(url):
    """Valida que la URL responda antes de proceder con las capturas"""
    # Importar requests solo cuando se necesite
    try:
        import requests
        from requests.exceptions import RequestException, Timeout, ConnectionError
    except ImportError:
        print("‚ùå Error: La librer√≠a 'requests' no est√° instalada")
        print("üí° Instala con: pip install requests")
        return False
    
    print(f"üîç Validando URL: {url}")
    
    try:
        # Intentar una petici√≥n HEAD primero (m√°s r√°pida)
        response = requests.head(url, timeout=10, allow_redirects=True)
        
        # Si HEAD no es soportado, intentar GET
        if response.status_code == 405:  # Method Not Allowed
            response = requests.get(url, timeout=10, allow_redirects=True)
        
        if response.status_code == 200:
            print(f"‚úÖ URL v√°lida (Status: {response.status_code})")
            return True
        else:
            print(f"‚ö†Ô∏è URL responde pero con status: {response.status_code}")
            # Permitir algunos c√≥digos que pueden funcionar con Playwright
            if response.status_code in [301, 302, 303, 307, 308]:
                print(f"üìù Redireccionamiento detectado, continuando...")
                return True
            return False
            
    except (ConnectionError, Timeout) as e:
        print(f"‚ùå Error de conexi√≥n: {e}")
        return False
    except RequestException as e:
        print(f"‚ùå Error en la petici√≥n: {e}")
        return False
    except Exception as e:
        print(f"‚ùå Error inesperado validando URL: {e}")
        return False

def extraer_nombre_cliente(url):
    """Extrae el nombre del cliente desde la URL del dominio"""
    try:
        parsed = urlparse(url)
        domain = parsed.netloc.lower()
        # Remover www. si existe
        if domain.startswith('www.'):
            domain = domain[4:]
        # Remover extensi√≥n del dominio
        nombre = domain.split('.')[0]
        # Limpiar caracteres especiales
        nombre = re.sub(r'[^a-zA-Z0-9]', '', nombre)
        return nombre
    except:
        return "sitio_web"

def crear_nombre_archivo(url, device, timestamp, es_completa=False):
    """Crea nombre descriptivo para el archivo"""
    try:
        parsed = urlparse(url)
        # Extraer path y limpiar
        path = parsed.path.strip('/')
        if not path:
            descripcion = "pagina-principal"
        else:
            descripcion = path.replace('/', '-').replace('#', '-seccion-')
        
        # Limpiar caracteres especiales
        descripcion = re.sub(r'[^a-zA-Z0-9\-]', '', descripcion)
        if not descripcion:
            descripcion = "captura"
            
        # A√±adir sufijo si es captura completa
        sufijo = "-completa" if es_completa else ""
        
        return f"{descripcion}-{device}{sufijo}-{timestamp}.png"
    except:
        sufijo = "-completa" if es_completa else ""
        return f"captura-{device}{sufijo}-{timestamp}.png"

def wait_for_animations(page, wait_time):
    """Espera el tiempo especificado para que carguen las animaciones"""
    if wait_time > 0:
        print(f"‚è≥ Esperando {wait_time} segundos para que carguen las animaciones...")
        time.sleep(wait_time)

def smooth_scroll_page(page):
    """Realiza scroll suave hacia abajo para disparar animaciones basadas en scroll"""
    print("üìú Realizando scroll suave para disparar animaciones...")
    
    # Obtener la altura total de la p√°gina
    total_height = page.evaluate("document.body.scrollHeight")
    viewport_height = page.evaluate("window.innerHeight")
    
    print(f"üìè Altura total de la p√°gina: {total_height}px, Viewport: {viewport_height}px")
    
    # Scroll optimizado - pasos de 80px (balance entre velocidad y efectividad)
    step_size = 80
    steps = int(total_height / step_size)
    
    print(f"üîÑ Realizando scroll suave en {steps} pasos de {step_size}px...")
    
    for i in range(steps):
        # Usar scrollBy para scroll incremental natural
        page.evaluate(f"""
            window.scrollBy(0, {step_size});
            window.dispatchEvent(new Event('scroll'));
        """)
        
        # Pausa corta optimizada (0.08s - r√°pido pero efectivo)
        time.sleep(0.08)
        
        # Mostrar progreso cada 20% del recorrido
        progress = (i / steps) * 100
        if progress % 20 < (100 / steps):
            print(f"üìç Progreso: {int(progress)}% ({i * step_size}px de {total_height}px)")
    
    # Asegurar que llegamos al final
    page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
    print("üìç Llegado al final de la p√°gina")
    
    # Forzar estado final de animaciones comunes
    print("‚ú® Forzando estado final de animaciones...")
    page.evaluate("""
        // AOS (Animate On Scroll)
        document.querySelectorAll('[data-aos]').forEach(el => {
            el.classList.add('aos-animate');
            el.style.opacity = '1';
            el.style.transform = 'none';
        });
        
        // GSAP ScrollTrigger refresh
        if (typeof ScrollTrigger !== 'undefined') {
            ScrollTrigger.getAll().forEach(st => st.refresh());
        }
        
        // Intersection Observer - forzar visibilidad
        document.querySelectorAll('[class*="fade"], [class*="slide"], [class*="animate"]').forEach(el => {
            if (el.style.opacity === '0' || el.style.opacity === '') {
                el.style.opacity = '1';
            }
            if (el.style.visibility === 'hidden') {
                el.style.visibility = 'visible';
            }
        });
        
        // Disparar scroll event final
        window.dispatchEvent(new Event('scroll'));
        window.dispatchEvent(new Event('resize'));
    """)
    
    # Pausa final para que se completen las animaciones
    time.sleep(1.0)
    print("‚úÖ Scroll completado - p√°gina lista para captura desde el final")

def capturar_url(url, device_key, device_config, base_path, timestamp, wait_time=3.0, smooth_scroll=False):
    """Captura screenshots de una URL en un dispositivo espec√≠fico"""
    # Importar playwright solo cuando se necesite
    try:
        from playwright.sync_api import sync_playwright
    except ImportError:
        print("‚ùå Error: La librer√≠a 'playwright' no est√° instalada")
        print("üí° Instala con: pip install playwright")
        print("üí° Luego ejecuta: playwright install")
        return
    
    print(f"üì± Configurando: {device_config['nombre']} ({device_config['width']}x{device_config['height']})")
    
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page(viewport=device_config)
        
        try:
            print(f"üì∏ Navegando a: {url}")
            page.goto(url, wait_until="networkidle")
            
            # Esperar tiempo especificado para animaciones
            wait_for_animations(page, wait_time)
            
            # Captura normal (viewport)
            archivo_normal = crear_nombre_archivo(url, device_key, timestamp, False)
            ruta_normal = base_path / archivo_normal
            page.screenshot(path=str(ruta_normal))
            print(f"‚úÖ Captura viewport: {ruta_normal}")
            
            # Captura completa (p√°gina scrolleable)
            if smooth_scroll:
                smooth_scroll_page(page)
                # Esperar tiempo m√≠nimo despu√©s del scroll suave
                wait_for_animations(page, 1.0)  # Tiempo m√≠nimo optimizado
            
            archivo_completa = crear_nombre_archivo(url, device_key, timestamp, True)
            ruta_completa = base_path / archivo_completa
            page.screenshot(path=str(ruta_completa), full_page=True)
            print(f"‚úÖ Captura completa: {ruta_completa}")
            
        except Exception as e:
            print(f"‚ùå Error capturando {url} en {device_key}: {e}")
        finally:
            browser.close()

def crear_estructura_carpetas(cliente, devices_a_usar, output_dir=None):
    """Crea la estructura de carpetas solo para los dispositivos que se van a usar"""
    # Determinar el directorio base de salida
    if output_dir:
        # Si se especifica un directorio personalizado
        base_output = Path(output_dir).expanduser()
    else:
        # Por defecto: carpeta 'capturas' en el directorio del proyecto
        base_output = Path.cwd() / "capturas"
    
    # Crear la ruta completa con el nombre del cliente
    base_path = base_output / cliente
    
    for device_key in devices_a_usar:
        device_path = base_path / device_key
        device_path.mkdir(parents=True, exist_ok=True)
        print(f"üìÅ Carpeta verificada: {device_path}")
    
    return base_path

def main():
    parser = argparse.ArgumentParser(
        description="""
ScriptShotWeb - Herramienta profesional para capturas de pantalla web

Esta herramienta permite realizar capturas de pantalla optimizadas de sitios web
en m√∫ltiples dispositivos y tama√±os, con soporte para animaciones y efectos de scroll.
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EJEMPLOS DE USO:
  
  Captura b√°sica en un dispositivo:
    scriptshotweb https://example.com --device desktop
    scriptshotweb https://site.com --device mobile-17
  
  Captura en todos los dispositivos:
    scriptshotweb https://example.com --all-devices
  
  Captura con tiempo de espera personalizado:
    scriptshotweb https://site.com --device tablet --wait-time 7
  
  Captura con scroll suave para animaciones:
    scriptshotweb https://animated-site.com --all-devices --smooth-scroll
  
  Modo super (completo y optimizado):
    scriptshotweb https://complex-site.com --super
  
  Combinando opciones:
    scriptshotweb https://site.com --device desktop --wait-time 4 --smooth-scroll
  
  Guardar en directorio personalizado:
    scriptshotweb https://site.com --super --output-dir ~/Proyectos/Capturas

DISPOSITIVOS DISPONIBLES:
  mobile-se    iPhone SE (375x667)
  mobile-17    iPhone 17 (393x852)  
  tablet       iPad (768x1024)
  desktop      Desktop (1920x1080)

NOTAS:
  ‚Ä¢ Las capturas se guardan en carpetas organizadas por cliente y dispositivo
  ‚Ä¢ El nombre del cliente se extrae autom√°ticamente de la URL
  ‚Ä¢ Se generan dos tipos de captura: viewport y p√°gina completa
  ‚Ä¢ El modo --super activa autom√°ticamente: all-devices + smooth-scroll + wait-time 2s (optimizado)
        """
    )
    
    parser.add_argument('url', 
                       nargs='?',  # Hacer que URL sea opcional
                       help='URL completa del sitio web a capturar (ej: https://example.com)')
    
    parser.add_argument('-all', '--all-devices', 
                       action='store_true',
                       help='Capturar en todos los dispositivos disponibles (mobile-se, mobile-17, tablet, desktop)')
    
    parser.add_argument('--device', 
                       choices=list(TAMA√ëOS.keys()),
                       help='Dispositivo espec√≠fico para capturar. Opciones: mobile-se, mobile-17, tablet, desktop')
    
    parser.add_argument('--cliente',
                       help='Nombre personalizado del cliente para organizar capturas (se detecta autom√°ticamente desde URL si no se especifica)')
    
    parser.add_argument('--output-dir',
                       help='Directorio personalizado para guardar las capturas (default: ./capturas/ en el directorio actual)')
    
    parser.add_argument('--wait-time',
                       type=float,
                       default=3.0,
                       help='Tiempo de espera en segundos para que carguen animaciones y contenido din√°mico (default: 3.0)')
    
    parser.add_argument('--smooth-scroll',
                       action='store_true',
                       help='Realizar scroll suave hacia abajo antes de captura completa para disparar animaciones basadas en scroll')
    
    parser.add_argument('--super',
                       action='store_true',
                       help='üöÄ Modo super: activa autom√°ticamente --all-devices + --smooth-scroll + wait-time optimizado (2s) para capturas completas y r√°pidas')
    
    parser.add_argument('--info',
                       action='store_true',
                       help='üìñ Mostrar gu√≠a completa y ejemplos detallados de uso')
    
    args = parser.parse_args()
    
    # Si se solicita informaci√≥n extendida, mostrarla y salir
    if args.info:
        mostrar_ayuda_extendida()
        sys.exit(0)
    
    # Si no es --info, entonces URL es requerida
    if not args.url:
        print("‚ùå Error: URL es requerida")
        print("üí° Usa --help para ver opciones b√°sicas o --info para gu√≠a completa")
        parser.print_help()
        sys.exit(1)
    
    # Si se usa --super, activar autom√°ticamente las opciones optimizadas
    if args.super:
        args.all_devices = True
        args.smooth_scroll = True
        # Si no se especific√≥ wait_time personalizado, usar 2 segundos para modo super (optimizado)
        if args.wait_time == 3.0:  # valor default
            args.wait_time = 2.0
    
    # Validar argumentos
    if not args.all_devices and not args.device and not args.super:
        print("‚ùå Error: Debes especificar -all, --device o --super")
        print("üí° Usa --help para ver opciones b√°sicas o --info para gu√≠a completa")
        parser.print_help()
        sys.exit(1)
    
    # VALIDAR URL ANTES DE CREAR CARPETAS
    if not validar_url(args.url):
        print(f"‚ùå Error: La URL {args.url} no responde o no es accesible")
        print("üí° Verifica que la URL sea correcta y est√© disponible")
        sys.exit(1)
    
    # Detectar cliente autom√°ticamente o usar el proporcionado
    cliente = args.cliente or extraer_nombre_cliente(args.url)
    
    # Generar timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Determinar dispositivos a usar
    if args.all_devices:
        devices_a_usar = list(TAMA√ëOS.keys())
        if args.super:
            print(f"üöÄ MODO SUPER ACTIVADO üöÄ")
            print(f"üì± Capturando URL: {args.url}")
            print(f"üë§ Cliente: {cliente}")
            print(f"üì± Dispositivos: {', '.join(devices_a_usar)}")
            print(f"‚è≥ Tiempo de espera: {args.wait_time}s")
            print(f"üìú Scroll suave: ‚úÖ Activado")
        else:
            print(f"üöÄ Capturando URL: {args.url}")
            print(f"üë§ Cliente: {cliente}")
            print(f"üì± Dispositivos: {', '.join(devices_a_usar)}")
    else:
        devices_a_usar = [args.device]
        print(f"üöÄ Capturando URL: {args.url}")
        print(f"üë§ Cliente: {cliente}")
        print(f"üì± Dispositivo: {args.device}")
        if args.smooth_scroll:
            print(f"üìú Scroll suave: ‚úÖ Activado")
        if args.wait_time != 3.0:
            print(f"‚è≥ Tiempo de espera: {args.wait_time}s")
    
    # Crear estructura de carpetas SOLO para dispositivos solicitados
    base_path = crear_estructura_carpetas(cliente, devices_a_usar, args.output_dir)
    
    print(f"üìÅ Carpeta base: {base_path}")
    print("="*60)
    
    # Realizar capturas
    for i, device_key in enumerate(devices_a_usar, 1):
        print(f"\n[{i}/{len(devices_a_usar)}] Procesando {device_key}...")
        device_config = TAMA√ëOS[device_key]
        device_path = base_path / device_key
        
        capturar_url(args.url, device_key, device_config, device_path, timestamp, args.wait_time, args.smooth_scroll)
    
    print(f"\nüéâ ¬°Capturas completadas!")
    print(f"üìÇ Revisa las im√°genes en: {base_path}")

if __name__ == "__main__":
    main()