#!/usr/bin/env python3
"""
ScriptShotWeb - Herramienta simplificada para capturas de pantalla web
Uso: scriptshotweb URL [-all] [--device DEVICE] [--wait-time SECONDS] [--smooth-scroll] [--super]

Ejemplos:
  scriptshotweb http://mariadelasmercedes.com/contacto -all
  scriptshotweb https://mecalito.com --device mobile-17
  scriptshotweb https://example.com --device tablet --wait-time 5 --smooth-scroll
  scriptshotweb https://site.com --super  # Modo completo optimizado
"""

import argparse
import sys
from pathlib import Path
from urllib.parse import urlparse
from datetime import datetime
import re
import time
# Importaciones de playwright y requests se harÃ¡n mÃ¡s tarde para permitir que --help funcione

def mostrar_ayuda_extendida():
    """Muestra informaciÃ³n adicional sobre el uso del script"""
    ayuda = """
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘                           SCRIPTSHOTWEB - GUÃA COMPLETA                      â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

ğŸ“– DESCRIPCIÃ“N:
   ScriptShotWeb es una herramienta profesional para realizar capturas de pantalla
   de sitios web en mÃºltiples dispositivos, optimizada para sitios modernos con
   animaciones, efectos de scroll y contenido dinÃ¡mico.

ğŸ¯ CARACTERÃSTICAS PRINCIPALES:
   â€¢ Capturas en 4 tamaÃ±os de dispositivo predefinidos
   â€¢ Soporte para animaciones y contenido que se carga con delay
   â€¢ Scroll suave para disparar animaciones basadas en scroll
   â€¢ OrganizaciÃ³n automÃ¡tica de archivos por cliente y dispositivo
   â€¢ Modo super para captura completa optimizada

ğŸ“± DISPOSITIVOS DISPONIBLES:
   mobile-se  â”‚ iPhone SE      â”‚ 375 Ã— 667   â”‚ MÃ³vil pequeÃ±o
   mobile-17  â”‚ iPhone 17      â”‚ 393 Ã— 852   â”‚ MÃ³vil moderno  
   tablet     â”‚ iPad           â”‚ 768 Ã— 1024  â”‚ Tablet estÃ¡ndar
   desktop    â”‚ Desktop        â”‚ 1920 Ã— 1080 â”‚ Escritorio HD

ğŸš€ MODOS DE USO:

   BÃ¡sico (un dispositivo):
   $ scriptshotweb https://example.com --device desktop

   Completo (todos los dispositivos):  
   $ scriptshotweb https://example.com --all-devices

   Super optimizado (recomendado para sitios complejos):
   $ scriptshotweb https://example.com --super

âš™ï¸  OPCIONES AVANZADAS:
   --wait-time SEGUNDOS    â”‚ Tiempo de espera para animaciones (default: 3s)
   --smooth-scroll         â”‚ Scroll suave antes de captura completa
   --cliente NOMBRE        â”‚ Nombre personalizado para organizar archivos
   --output-dir PATH       â”‚ Directorio personalizado de salida

ğŸ“‚ ESTRUCTURA DE ARCHIVOS:
   Las capturas se guardan por defecto en:
   ./capturas/ (carpeta en el proyecto)
   â””â”€â”€ [cliente]/
       â”œâ”€â”€ mobile-se/
       â”œâ”€â”€ mobile-17/ 
       â”œâ”€â”€ tablet/
       â””â”€â”€ desktop/
           â”œâ”€â”€ pagina-viewport-20241004_143025.png
           â””â”€â”€ pagina-completa-20241004_143025.png
   
   Usa --output-dir para guardar en otra ubicaciÃ³n como:
   ~/Pictures/ScriptShotWeb o ~/Downloads/ScriptShotWeb

ğŸ’¡ CONSEJOS:
   â€¢ Usa --super para sitios con muchas animaciones
   â€¢ Usa --wait-time mayor para sitios lentos
   â€¢ El scroll suave es ideal para lazy loading y parallax
   â€¢ Las URLs deben incluir http:// o https://

"""
    print(ayuda)

# ConfiguraciÃ³n de dispositivos/tamaÃ±os
TAMAÃ‘OS = {
    "mobile-se": {"width": 375, "height": 667, "nombre": "iPhone SE"},
    "mobile-17": {"width": 393, "height": 852, "nombre": "iPhone 17"},
    "tablet": {"width": 768, "height": 1024, "nombre": "iPad"},
    "desktop": {"width": 1920, "height": 1080, "nombre": "Desktop"}
}

def validar_url(url):
    """Valida que la URL responda antes de proceder con las capturas"""
    # Importar requests solo cuando se necesite
    try:
        import requests
        from requests.exceptions import RequestException, Timeout, ConnectionError
    except ImportError:
        print("âŒ Error: La librerÃ­a 'requests' no estÃ¡ instalada")
        print("ğŸ’¡ Instala con: pip install requests")
        return False
    
    print(f"ğŸ” Validando URL: {url}")
    
    try:
        # Intentar una peticiÃ³n HEAD primero (mÃ¡s rÃ¡pida)
        response = requests.head(url, timeout=10, allow_redirects=True)
        
        # Si HEAD no es soportado, intentar GET
        if response.status_code == 405:  # Method Not Allowed
            response = requests.get(url, timeout=10, allow_redirects=True)
        
        if response.status_code == 200:
            print(f"âœ… URL vÃ¡lida (Status: {response.status_code})")
            return True
        else:
            print(f"âš ï¸ URL responde pero con status: {response.status_code}")
            # Permitir algunos cÃ³digos que pueden funcionar con Playwright
            if response.status_code in [301, 302, 303, 307, 308]:
                print(f"ğŸ“ Redireccionamiento detectado, continuando...")
                return True
            return False
            
    except (ConnectionError, Timeout) as e:
        print(f"âŒ Error de conexiÃ³n: {e}")
        return False
    except RequestException as e:
        print(f"âŒ Error en la peticiÃ³n: {e}")
        return False
    except Exception as e:
        print(f"âŒ Error inesperado validando URL: {e}")
        return False

def extraer_nombre_cliente(url):
    """Extrae el nombre del cliente desde la URL del dominio"""
    try:
        parsed = urlparse(url)
        domain = parsed.netloc.lower()
        # Remover www. si existe
        if domain.startswith('www.'):
            domain = domain[4:]
        # Remover extensiÃ³n del dominio
        nombre = domain.split('.')[0]
        # Limpiar caracteres especiales
        nombre = re.sub(r'[^a-zA-Z0-9]', '', nombre)
        return nombre
    except:
        return "sitio_web"

def crear_nombre_archivo(url, device, timestamp, es_completa=False):
    """Crea nombre descriptivo para el archivo"""
    try:
        parsed = urlparse(url)
        # Extraer path y limpiar
        path = parsed.path.strip('/')
        if not path:
            descripcion = "pagina-principal"
        else:
            descripcion = path.replace('/', '-').replace('#', '-seccion-')
        
        # Limpiar caracteres especiales
        descripcion = re.sub(r'[^a-zA-Z0-9\-]', '', descripcion)
        if not descripcion:
            descripcion = "captura"
            
        # AÃ±adir sufijo si es captura completa
        sufijo = "-completa" if es_completa else ""
        
        return f"{descripcion}-{device}{sufijo}-{timestamp}.png"
    except:
        sufijo = "-completa" if es_completa else ""
        return f"captura-{device}{sufijo}-{timestamp}.png"

def wait_for_animations(page, wait_time):
    """Espera el tiempo especificado para que carguen las animaciones"""
    if wait_time > 0:
        print(f"â³ Esperando {wait_time} segundos para que carguen las animaciones...")
        time.sleep(wait_time)

def smooth_scroll_page(page):
    """Realiza scroll suave hacia abajo para disparar animaciones basadas en scroll"""
    print("ğŸ“œ Realizando scroll suave para disparar animaciones...")
    
    # Obtener la altura total de la pÃ¡gina
    total_height = page.evaluate("document.body.scrollHeight")
    viewport_height = page.evaluate("window.innerHeight")
    
    print(f"ğŸ“ Altura total de la pÃ¡gina: {total_height}px, Viewport: {viewport_height}px")
    
    # Scroll optimizado - pasos de 80px (balance entre velocidad y efectividad)
    step_size = 80
    steps = int(total_height / step_size)
    
    print(f"ğŸ”„ Realizando scroll suave en {steps} pasos de {step_size}px...")
    
    for i in range(steps):
        # Usar scrollBy para scroll incremental natural
        page.evaluate(f"""
            window.scrollBy(0, {step_size});
            window.dispatchEvent(new Event('scroll'));
        """)
        
        # Pausa corta optimizada (0.08s - rÃ¡pido pero efectivo)
        time.sleep(0.08)
        
        # Mostrar progreso cada 20% del recorrido
        progress = (i / steps) * 100
        if progress % 20 < (100 / steps):
            print(f"ğŸ“ Progreso: {int(progress)}% ({i * step_size}px de {total_height}px)")
    
    # Asegurar que llegamos al final
    page.evaluate("window.scrollTo(0, document.body.scrollHeight)")
    print("ğŸ“ Llegado al final de la pÃ¡gina")
    
    # Forzar estado final de animaciones comunes
    print("âœ¨ Forzando estado final de animaciones...")
    page.evaluate("""
        // AOS (Animate On Scroll)
        document.querySelectorAll('[data-aos]').forEach(el => {
            el.classList.add('aos-animate');
            el.style.opacity = '1';
            el.style.transform = 'none';
        });
        
        // GSAP ScrollTrigger refresh
        if (typeof ScrollTrigger !== 'undefined') {
            ScrollTrigger.getAll().forEach(st => st.refresh());
        }
        
        // Intersection Observer - forzar visibilidad
        document.querySelectorAll('[class*="fade"], [class*="slide"], [class*="animate"]').forEach(el => {
            if (el.style.opacity === '0' || el.style.opacity === '') {
                el.style.opacity = '1';
            }
            if (el.style.visibility === 'hidden') {
                el.style.visibility = 'visible';
            }
        });
        
        // Disparar scroll event final
        window.dispatchEvent(new Event('scroll'));
        window.dispatchEvent(new Event('resize'));
    """)
    
    # Pausa final para que se completen las animaciones
    time.sleep(1.0)
    print("âœ… Scroll completado - pÃ¡gina lista para captura desde el final")

def capturar_url(url, device_key, device_config, base_path, timestamp, wait_time=3.0, smooth_scroll=False):
    """Captura screenshots de una URL en un dispositivo especÃ­fico"""
    # Importar playwright solo cuando se necesite
    try:
        from playwright.sync_api import sync_playwright
    except ImportError:
        print("âŒ Error: La librerÃ­a 'playwright' no estÃ¡ instalada")
        print("ğŸ’¡ Instala con: pip install playwright")
        print("ğŸ’¡ Luego ejecuta: playwright install")
        return
    
    print(f"ğŸ“± Configurando: {device_config['nombre']} ({device_config['width']}x{device_config['height']})")
    
    with sync_playwright() as p:
        browser = p.chromium.launch(headless=True)
        page = browser.new_page(viewport=device_config)
        
        try:
            print(f"ğŸ“¸ Navegando a: {url}")
            page.goto(url, wait_until="networkidle")
            
            # Esperar tiempo especificado para animaciones
            wait_for_animations(page, wait_time)
            
            # Captura normal (viewport)
            archivo_normal = crear_nombre_archivo(url, device_key, timestamp, False)
            ruta_normal = base_path / archivo_normal
            page.screenshot(path=str(ruta_normal))
            print(f"âœ… Captura viewport: {ruta_normal}")
            
            # Captura completa (pÃ¡gina scrolleable)
            if smooth_scroll:
                smooth_scroll_page(page)
                # Esperar tiempo mÃ­nimo despuÃ©s del scroll suave
                wait_for_animations(page, 1.0)  # Tiempo mÃ­nimo optimizado
            
            archivo_completa = crear_nombre_archivo(url, device_key, timestamp, True)
            ruta_completa = base_path / archivo_completa
            page.screenshot(path=str(ruta_completa), full_page=True)
            print(f"âœ… Captura completa: {ruta_completa}")
            
        except Exception as e:
            print(f"âŒ Error capturando {url} en {device_key}: {e}")
        finally:
            browser.close()

def crear_estructura_carpetas(cliente, devices_a_usar, output_dir=None):
    """Crea la estructura de carpetas solo para los dispositivos que se van a usar"""
    # Determinar el directorio base de salida
    if output_dir:
        # Si se especifica un directorio personalizado
        base_output = Path(output_dir).expanduser()
    else:
        # Por defecto: carpeta 'capturas' en el directorio del proyecto
        base_output = Path.cwd() / "capturas"
    
    # Crear la ruta completa con el nombre del cliente
    base_path = base_output / cliente
    
    for device_key in devices_a_usar:
        device_path = base_path / device_key
        device_path.mkdir(parents=True, exist_ok=True)
        print(f"ğŸ“ Carpeta verificada: {device_path}")
    
    return base_path

def main():
    parser = argparse.ArgumentParser(
        description="""
ScriptShotWeb - Herramienta profesional para capturas de pantalla web

Esta herramienta permite realizar capturas de pantalla optimizadas de sitios web
en mÃºltiples dispositivos y tamaÃ±os, con soporte para animaciones y efectos de scroll.
        """,
        formatter_class=argparse.RawDescriptionHelpFormatter,
        epilog="""
EJEMPLOS DE USO:
  
  Captura bÃ¡sica en un dispositivo:
    scriptshotweb https://example.com --device desktop
    scriptshotweb https://site.com --device mobile-17
  
  Captura en todos los dispositivos:
    scriptshotweb https://example.com --all-devices
  
  Captura con tiempo de espera personalizado:
    scriptshotweb https://site.com --device tablet --wait-time 7
  
  Captura con scroll suave para animaciones:
    scriptshotweb https://animated-site.com --all-devices --smooth-scroll
  
  Modo super (completo y optimizado):
    scriptshotweb https://complex-site.com --super
  
  Combinando opciones:
    scriptshotweb https://site.com --device desktop --wait-time 4 --smooth-scroll
  
  Guardar en directorio personalizado:
    scriptshotweb https://site.com --super --output-dir ~/Proyectos/Capturas

DISPOSITIVOS DISPONIBLES:
  mobile-se    iPhone SE (375x667)
  mobile-17    iPhone 17 (393x852)  
  tablet       iPad (768x1024)
  desktop      Desktop (1920x1080)

NOTAS:
  â€¢ Las capturas se guardan en carpetas organizadas por cliente y dispositivo
  â€¢ El nombre del cliente se extrae automÃ¡ticamente de la URL
  â€¢ Se generan dos tipos de captura: viewport y pÃ¡gina completa
  â€¢ El modo --super activa automÃ¡ticamente: all-devices + smooth-scroll + wait-time 2s (optimizado)
        """
    )
    
    parser.add_argument('url', 
                       nargs='?',  # Hacer que URL sea opcional
                       help='URL completa del sitio web a capturar (ej: https://example.com)')
    
    parser.add_argument('-all', '--all-devices', 
                       action='store_true',
                       help='Capturar en todos los dispositivos disponibles (mobile-se, mobile-17, tablet, desktop)')
    
    parser.add_argument('--device', 
                       choices=list(TAMAÃ‘OS.keys()),
                       help='Dispositivo especÃ­fico para capturar. Opciones: mobile-se, mobile-17, tablet, desktop')
    
    parser.add_argument('--cliente',
                       help='Nombre personalizado del cliente para organizar capturas (se detecta automÃ¡ticamente desde URL si no se especifica)')
    
    parser.add_argument('--output-dir',
                       help='Directorio personalizado para guardar las capturas (default: ./capturas/ en el directorio actual)')
    
    parser.add_argument('--wait-time',
                       type=float,
                       default=3.0,
                       help='Tiempo de espera en segundos para que carguen animaciones y contenido dinÃ¡mico (default: 3.0)')
    
    parser.add_argument('--smooth-scroll',
                       action='store_true',
                       help='Realizar scroll suave hacia abajo antes de captura completa para disparar animaciones basadas en scroll')
    
    parser.add_argument('--super',
                       action='store_true',
                       help='ğŸš€ Modo super: activa automÃ¡ticamente --all-devices + --smooth-scroll + wait-time optimizado (2s) para capturas completas y rÃ¡pidas')
    
    parser.add_argument('--info',
                       action='store_true',
                       help='ğŸ“– Mostrar guÃ­a completa y ejemplos detallados de uso')
    
    args = parser.parse_args()
    
    # Si se solicita informaciÃ³n extendida, mostrarla y salir
    if args.info:
        mostrar_ayuda_extendida()
        sys.exit(0)
    
    # Si no es --info, entonces URL es requerida
    if not args.url:
        print("âŒ Error: URL es requerida")
        print("ğŸ’¡ Usa --help para ver opciones bÃ¡sicas o --info para guÃ­a completa")
        parser.print_help()
        sys.exit(1)
    
    # Si se usa --super, activar automÃ¡ticamente las opciones optimizadas
    if args.super:
        args.all_devices = True
        args.smooth_scroll = True
        # Si no se especificÃ³ wait_time personalizado, usar 2 segundos para modo super (optimizado)
        if args.wait_time == 3.0:  # valor default
            args.wait_time = 2.0
    
    # Validar argumentos
    if not args.all_devices and not args.device and not args.super:
        print("âŒ Error: Debes especificar -all, --device o --super")
        print("ğŸ’¡ Usa --help para ver opciones bÃ¡sicas o --info para guÃ­a completa")
        parser.print_help()
        sys.exit(1)
    
    # VALIDAR URL ANTES DE CREAR CARPETAS
    if not validar_url(args.url):
        print(f"âŒ Error: La URL {args.url} no responde o no es accesible")
        print("ğŸ’¡ Verifica que la URL sea correcta y estÃ© disponible")
        sys.exit(1)
    
    # Detectar cliente automÃ¡ticamente o usar el proporcionado
    cliente = args.cliente or extraer_nombre_cliente(args.url)
    
    # Generar timestamp
    timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
    
    # Determinar dispositivos a usar
    if args.all_devices:
        devices_a_usar = list(TAMAÃ‘OS.keys())
        if args.super:
            print(f"ğŸš€ MODO SUPER ACTIVADO ğŸš€")
            print(f"ğŸ“± Capturando URL: {args.url}")
            print(f"ğŸ‘¤ Cliente: {cliente}")
            print(f"ğŸ“± Dispositivos: {', '.join(devices_a_usar)}")
            print(f"â³ Tiempo de espera: {args.wait_time}s")
            print(f"ğŸ“œ Scroll suave: âœ… Activado")
        else:
            print(f"ğŸš€ Capturando URL: {args.url}")
            print(f"ğŸ‘¤ Cliente: {cliente}")
            print(f"ğŸ“± Dispositivos: {', '.join(devices_a_usar)}")
    else:
        devices_a_usar = [args.device]
        print(f"ğŸš€ Capturando URL: {args.url}")
        print(f"ğŸ‘¤ Cliente: {cliente}")
        print(f"ğŸ“± Dispositivo: {args.device}")
        if args.smooth_scroll:
            print(f"ğŸ“œ Scroll suave: âœ… Activado")
        if args.wait_time != 3.0:
            print(f"â³ Tiempo de espera: {args.wait_time}s")
    
    # Crear estructura de carpetas SOLO para dispositivos solicitados
    base_path = crear_estructura_carpetas(cliente, devices_a_usar, args.output_dir)
    
    print(f"ğŸ“ Carpeta base: {base_path}")
    print("="*60)
    
    # Realizar capturas
    for i, device_key in enumerate(devices_a_usar, 1):
        print(f"\n[{i}/{len(devices_a_usar)}] Procesando {device_key}...")
        device_config = TAMAÃ‘OS[device_key]
        device_path = base_path / device_key
        
        capturar_url(args.url, device_key, device_config, device_path, timestamp, args.wait_time, args.smooth_scroll)
    
    print(f"\nğŸ‰ Â¡Capturas completadas!")
    print(f"ğŸ“‚ Revisa las imÃ¡genes en: {base_path}")

if __name__ == "__main__":
    main()